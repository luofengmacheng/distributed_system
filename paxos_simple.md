## Paxos Made Simple

原文链接：[Paxos Made Simple](http://css.csail.mit.edu/6.824/2014/papers/paxos-simple.pdf)

## 1 绪论

我们常常认为，实现容错的分布式系统中使用的Paxos算法是很难理解的，可能是因为论文最初使用的是希腊语。事实上，它是分布式系统中很简单而且明显的算法。它的基本思想是一致性算法：synod算法。下一小节会展示这个一致性算法满足我们的需求。最后一部分会解释完整的Paxos算法，。

## 2 一致性算法

### 2.1 问题

假设一些进程都能够提案值。一致性算法保证只选择这些提案值的其中一个。如果没有提案的值，那么，就没有选择值。如果选择了一个值，那么，进程就必须能够学习到这个值。一致性的安全要求是：

* 提案的值只有一个可能被选择
* 只有一个值被选择
* 只有选择了一个值，进程才能知道已经选择了一个值。

我们不会试图指定精确的活性要求(We won’t try to specify precise liveness requirements)。然而，这个目标是为了保证，某个提案值被选择，并且，如果选择了一个值，那么，最终进程会学到这个值。

我们让一致性算法中三类代理执行三种角色：proposers, acceptors和learners。在实现中，一个进程可能是多个代理，但是，这里从代理到进程的映射不是我们所关心的。

假设代理之间可以通过发送消息进行通信。这里，我们使用异步的、非Byzantine模型：

* 代理可以以任意速度运行，可能发生故障，可能重启。因为在选择一个值之后，所有的代理可能会故障，然后重启，这种情况下，只有某个发生故障重启的代理保存一些信息。
* 消息可以在任意长时间传送，可以重复，可以丢失，但是，不能发生错误。

### 2.2 选择一个值

选择一个值最简单的方式是：只有一个acceptor代理。一个proposer将一个提案值发送给acceptor代理，acceptor选择它收到的第一个提案值。虽然简单，但是，这种解决方案不能满足要求，因为，如果acceptor故障了，就不能继续往后运行。

因此，让我们试试另外一种选择值的方法。而且，有多个acceptor代理。一个proposer将一个提案值发送给一些acceptor。某个acceptor可能会接受这个提案值。当足够多的acceptor接受了这个值，那么，就选择这个值。多少算足够多呢？为了保证只选择一个值，我们让这个“足够多”包含任何大多数的代理。因为通常任何两个“大多数”至少包含一个acceptor，如果acceptor最多能接受一个值，那么这就是可行的。

没有故障和消息丢失，即使只有一个proposer提案一个值，我们想选择这个值。这就要求：

P1 acceptor必须接受它收到的第一个提案值。

但是，这个要求带来了一个问题。不同的proposer可以在同一时刻提案多个值，于是，就导致了每个acceptor都接受了一个值，但是，没有值是被大多数接受。甚至是只有两个提案值时，如果两个都有一半的acceptor接受，某个acceptor故障后会导致不知道应该学习哪个值。

P1和这个要求(当大多数acceptor接受了某个值，就选定了这个值)表明，必须允许acceptor接受超过一个提案值。我们跟踪acceptor接受的不同的提案值，给每个提案值分配一个自然数，因此，一个提案值包括一个提案的编号和一个值。为了防止混乱，我们要求，不同的提案值有不同的编号。这种方案依赖于实现，因此，到目前为止，我们只是进行了假设。当一个提案值被大多数acceptor接受，就选定了这个值。在这种情况下，我们就说选定了这个提案值。

我们允许选择多个提案值，但是，我们必须保证所有的提案值相同。(By induction on the proposal number, it suffices to guarantee:)

P2 选择了提案值v，那么，每个更高编号的提案值都是v

因为编号是按序的，P2保证了重要的安全属性：只有一个值被选择。

为了选择提案值，一个提案值必须被至少1个acceptor选择。因此，我们能够通过下面的方式满足P2：

P2a 如果选择了提案值v，那么，任何acceptor接受的每个更高编号的提案的值都是v。

我们仍然用P1保证选择了一些提案。因为通信是异步的，选择了一个提案的某些acceptor c不会再接受任何提案。假设一个新的proposer醒来，然后发送一个更高编号的提案，但是提案的值不同。P1要求c接受这个提案，这就妨碍了P1a。为了保持P1和P2a，就要去加强P2a：

P2b 如果选择了提案值v，那么，任何proposer发送的更高编号的提案值都是v。

因为在acceptor能够接受提案之前，这个提案必须是被一个proposer发送的，P2b暗含了P2a，P2a反过来又暗含了P2。

为了知道如何才能满足P2b，让我们考虑：我们如何能够证明我们所持有的值。我们假设，选择了某个提案，提案编号是m，提案的值是v，那么，任何提案的编号是n且n>m，于是，这个提案的值就是v。我们在n上用归纳法可以使得证明更加简单，因此，我们能够证明，编号为n的提案的值为v是基于额外的假设：每个发送的编号为m..(n-1)的提案的值为v。为了选择编号m，必须存在某个集合C，它由大部分的acceptor组成，以便C中的每个acceptor接受这个提案。将这与归纳假设结合，选择m的假设表明：

C中的每个acceptor已经接受了编号在m..(n-1)的一个提案，并且，任何acceptor接受的编号在m..(n-1)的提案的值是v。

因为任何包含大多数acceptor的集合S包含至少C中的一个成员，我们可以得出结论：编号为n的提案的值为v，这可以通过保证：

对于任何v和n，如果如果发出一个编号为n值为v的提案，那么，就有包含多数派的acceptor的集合S，以便(a)S中没有acceptor已经接受任何编号小于n的提案，(b)v是所有提案中编号最大的提案

因此，我们能够通过保证P2c的不变性来满足P2b。

为了保持P2c不变性，想要发送一个编号为n的提案的proposer必须学习小于n的最大编号的提案，如果有的话，它就已经或者会被多数派的acceptor中的每个acceptor接受。学习已被接受的提案是很简单的；预测未来的接受的提案是很难的。不去试图预测未来，proposer通过提取承诺：不会有任何接受的提案。换句话说，proposer要求acceptor不会接受任何编号小于n的提案。于是就有了下面发送提案的算法。

1 proposer选择一个新的提案，提案编号为n，并将它发送给某个acceptor集合中的每个成员，等待回应：

(a) 承诺不会再接受编号小于n的提案

(b) 已经接受的小于n的最大编号的提案

我将这样一个请求称为编号为n的prepare请求。

2 如果proposer收到了多数派acceptor的响应，那么，它就会发送一个编号为n值为v的提案，其中v是这些响应中编号最大的提案的值，或者如果响应报告没有提案，proposer就选择一个任意值。

proposer发送提案：向某个集合中的acceptor发送提案已经被接受的请求。(这里的acceptor集合不需要跟开始响应的acceptor集合相同)我们称之为acceptor请求。

以上描述了proposer的算法。关于acceptor呢？它能够接受两种proposer发送的请求：prepare请求和accept请求。acceptor能够忽略任何不违背安全的请求。因此，我们说只有当它被允许响应请求。它还能够响应prepare请求。它能够响应accept请求，接受提案，当且仅当它还没有承诺不接受提案。换句话说：

P1a 当且仅当acceptor还没有响应编号大于n的prepare请求，acceptor能够接受编号为n的提案。

观察到P1a包含P1。

现在，我们有了选择满足安全属性(假设提案标号不重复)要求的值的完整的算法。最终的算法还需要进行一点小的优化。

假设acceptor收到编号为n的prepare请求，但是，它已经响应了编号大于n的prepare请求，因此，它承诺不接受任何编号为n的提案。然后，没有理由要求acceptor响应新的prepare请求，因为，它不会接受任何proposer想要发送的编号为n的提案。因此，我们让acceptor忽略这样的prepare请求。我们也让acceptor忽略它已经接受的提案的prepare请求。

有了这个优化，acceptor只需要记住它曾经已经接受的提案的最大编号和它已经响应的prepare请求的最大编号。因为P2c必须保持不变性，无论是否发生故障，acceptor必须保存这个信息，即使它故障后重启。注意：proposer能够丢弃提案，不保存它的信息-只要它不试图发送另外的相同编号的提案。

将proposer和acceptor的行为放在一起，我们看到这个算法有两个阶段。

**Phase 1** (a) 一个proposer选择编号为n的提案，然后向多数派的acceptor发送编号为n的prepare请求。

(b) 如果一个acceptor收到了比它已经响应的prepare消息的编号大的prepare请求，那么，它会用已经接受的编号最大的提案响应这个请求并承诺：不会接受任何编号小于n的提案。

**Phase 2** (a) 如果proposer收到了从多数派的acceptor发送的编号为n的prepare请求的响应，那么，它会向那些acceptor发送accept请求，且编号为n，值为v，这里v是所有响应中编号最大的提案的值，或者任意值(如果响应报告没有提案)。

(b) 如果acceptor收到编号为n的提案的accept请求，当它还没有响应编号大于n的prepare请求时，它就会接受这个提案。

一个proposer能够发送多个提案，只要每个提案按照算法来。它能够在任何时刻丢弃协议中的提案。()如果某个proposer已经在试图尝试更大编号的提案，丢弃它可能是个好主意。因此，由于acceptor已经收到更高编号的prepare请求，acceptor会忽略prepare或者accept请求，那么，它就会告诉proposer丢弃这个提案。这是不对正确性产生影响的性能优化。

### 2.3 学会一个选择的值

为了学习某个值已经被选择，learner必须发现一个已经被多数派的acceptor接受的提案。明显的方式是，当每个acceptor接受了一个提案，它就会向所有的learner发送提案。这使得learner尽可能快地发现被选择的值，但是，它要求每个acceptor响应每个learner-响应的总数就是acceptor的数目与learner的数目的乘积。

没有Byzantine故障的假设使得learner可以很容易从其它learner知道已经选择了某个值。
