## Hypervisor-based Fault-tolerance

原文链接：[Hypervisor-based Fault-tolerance](http://css.csail.mit.edu/6.824/2014/papers/bressoud-hypervisor.pdf)

摘要：本文描述了实现容错计算机系统的协议。这些协议对虚拟机管理员的管理程序进行补充，使主虚拟机和它的备份虚拟机协同工作。就可以构造容错计算机系统。要求不改变硬件、操作系统或者引用程序。这个原型系统运行程序时，比裸机慢2倍。

## 1 绪论

实现容错的一个主流方案是当处理器工作异常时，复制处理器上的计算。副本之间需要协调，以便它们执行相同的指令序列，并产生相同的结果。本文描述了这种方案的一个新奇的实现。我们在硬件和操作系统之间加入了一个软件层。这样构造的容错计算机系统不需要改变硬件、操作系统和应用程序。

我们的方法的好处是：考虑了工程和推广市场的时间的开销。这是基于两个方面。首先，对于一个给定的指令集架构，厂商会开发一系列的实现，在这些系列中，成本/性能(原文是cost/performance，个人认为应该是性价比)提高了。其次，无论是用硬件还是软件实现副本协调，都是很微妙的(原文是subtle)。根据这些观察，我们注意到以下三个问题：

(1) 如果在硬件上实现副本协调，那么，在实现每个架构时都会产生设计开销。由于设计副本协调硬件很耗时，需要支持容错就必然落后于成本/性能曲线。

(2) 由于成熟的操作系统都是很复杂的，因此，向已经存在的操作系统中添加副本协调机制是很困难的。另外，对于每个平台支持的操作系统，都要做出改变。

(3) 如果副本协调问题留给应用程序开发人员，那么每个应用程序的开发人员都必须解决同样的问题。而且，所有的程序员都必须熟悉副本协调的细微差别。或者，所有的程序员都只能使用给定的一些接口或者抽象。

这些问题促使我们探索在计算机系统中实现副本协调时，可以将副本协调实现在硬件、操作系统还是应用程序部分。

hypervisor是实现了虚拟机的软件层次，这些虚拟机拥有和hypervisor运行的硬件相同的指令集架构。由于虚拟机的指令集架构跟裸机一样，运行在虚拟机上的软件不能区分hypervisor是否存在。最有名的hypervisor可能就是IBM为360/67开发的CP-67和之后为370大型机开发的VM/360了。

有多种原因使用hypervisor。hypervisor允许在一个处理器上同时存在多个操作系统或者是同一操作系统的多个版本。即使多个虚拟机同时运行同一个操作系统，hypervisor提供了隔离，它简化了保护和共享。然而，我们的研究没有关注hypervisor本身的价值和成本。我们关注的是增加hypervisor以支持副本协调和容错的价值和成本。

使用hypervisor实现副本协调是有诱惑力的-至少在理论上-因为它解决了上面提到的三个问题。对于给定的指令集架构的所有硬件实现，可以快速在hypervisor上实现副本协调，甚至包括那些当hypervisor写完时，并不存在的硬件的实现。这解决了问题(1)。对于问题(2)，我们注意到，在硬件上实现副本协调意味着一个实现可以满足运行在该指令集架构上的所有操作系统。最后，在hypervisor上实现副本协调可以解除应用程序开发人员实现副本协调时使用接口和抽象，这样就解决了问题(3)。

接下来的问题是，基于hypervisor的副本协调是否是可实现的。性能损失在哪里？本文解决了这些问题，描述了相关的协议和基于hypervisor的容错的原型系统的性能。这个原型系统运行程序比裸机要慢2倍。

本文的余下部分以下面的方式组织。第2部分，我们描述了一些协议。这些协议保证在不同的物理处理器上运行的两个虚拟机执行的指令序列是一样的。这些协议还要协调这些虚拟机发出的I/O。第3部分，我们会讨论原型系统。为了实现这个原型系统，我们为HP的PA-RISC架构实现了一个hypervisor，然后加入了我们的副本协调协议。第4部分，我们报告我们的原型系统的性能。除了讨论性能测试，我们还描述了可能改变原型的性能的变化的结果(we describe the consequences of variations that might improve performance of the prototype)。最后，第5部分，我们讨论了相关工作，第6部分我们进行总结然后给出未来研究方向的指导。

## 2 副本协调协议

使用主/备的方法实现容错，n个处理器实现的系统可以容n-1个错误。一个处理器作为主处理器，其它的都是备份处理器。为了获取服务，客户端向主处理器发送请求。主处理器对每个请求进行响应，并且通知备份处理器它的行为，以便当主处理器故障时，某个备份处理器可以代替它。

我们的容错虚拟机的实现在hypervisor中使用了主/备的方法。容t个错的虚拟机由一个主虚拟机和t个备份虚拟机构成。只要故障的处理器的个数等于或者少于t，容t个错的虚拟机就可以继续运行。

协议保证：

(1) 如果主处理器没有故障，备份虚拟机不会同外界进行通信；

(2) 如果主处理器故障了，某个备份虚拟机就会同外界通信，这样的话，外界并不知道主处理器的故障。对于虚拟机而言，“外界”包括虚拟机可以访问的虚拟机的I/O设备。

我们的协议使用了一个备份，并且实现了容1个错的虚拟机；容t个错的虚拟机是一样的。协议保证备份虚拟机执行的指令序列跟主虚拟机相同，备份处理器执行的每条指令的结果跟主处理器相同。协议还保证，当一个I/O操作正在执行时，如果主处理器故障了，备份处理器代替它时，外界不会看到异常的I/O请求序列。

需要做一个假设，以便备份虚拟机能够代替主虚拟机，考虑I/O设备的可访问性：

**I/O设备的可访问假设：**执行主虚拟机的处理器可以访问的I/O设备也能够被执行备份虚拟机的处理器访问。

第二个假设是必要的，因为hypervisor要模拟特定的指令。这些指令在hypervisor的执行时间可能跟直接在硬件上执行不同。使用hypervisor还可能影响程序可以访问的实际内存。因此，我们假设，虚拟机上运行的这个软件不会影响操作系统和其它程序的正确性：

**虚拟机假设：**加上hypervisor，系统和用户软件可以正确执行。

在下面讨论的其它假设考虑了执行多种指令的影响。(We ignore here the problem of replacing the backup after it fails or becames the primary)，因为这个问题对于副本协调是正交的，很容易解决。

### 2.1 相同的指令流

在我们的方案中，一条给定的指令必须产生相同的结果，无论它是被主虚拟机执行还是被备份虚拟机执行。这就要求两个关于指令执行的假设。HP的PA-RISC和大多数现代处理器满足这个两个假设。

定义虚拟机状态，它包括内存和寄存器，内存和寄存器只有在虚拟机执行指令时才会改变。主存、地址翻译寄存器、程序计数器和通用寄存器也是虚拟机状态的一部分，I/O设备的内容则不是。我们将指令集分为常规指令和环境指令，常规指令的行为完全由虚拟机状态决定，环境指令的行为则不是。比如，算术和数据移动的指令就是常规指令；读取时间、加载间隔计时器、执行I/O的指令就是环境指令。

为了让主备虚拟机执行相同的指令序列，主备虚拟机的开始状态一定相同。之后我们就要求每条指令在主备虚拟机上执行时有相同的结果。根据定义，执行常规指令的结果仅仅依赖于虚拟机状态。因此，常规指令可以直接在主备虚拟机上执行：

**常规指令假设：**虚拟机状态相同时，在两个处理器上执行相同的常规指令产生相同的结果。

比如，当给定相同的参数时，两条ADD指令得到相同的和。并且，两条相同的除法指令，如果除数为0，那么，会在指令流的相同地方触发一个异常。

另外一个假设保证，当执行环境指令时，主备虚拟机的hypervisor可以进行通信。这就能够让两边的hypervisor以相同的方式改变虚拟机状态。比如，这个假设使得备份虚拟机读取时钟的指令得到的值跟主虚拟机执行的指令(运行时间可能有点不同)返回的值相同。

**环境指令假设：** hypervisor模拟环境指令(而不是硬件直接执行)。这个模拟保证了，在相同的虚拟机状态下，两个处理器执行一条给定的环境指令，产生相同的结果。

为了确保主备虚拟机执行相同的指令序列，我们必须保证在它们的指令流中的相同位置传送相同的中断。hypervisor带来了帮助。主虚拟机的hypervisor能够缓冲I/O，并将I/O中断发送给备份虚拟机的hypervisor。并且，主虚拟机的hypervisor能够将执行主虚拟机的处理器上的关于时间间隔计时器的值的信息发送给备份虚拟机的hypervisor。因此，通过与主虚拟机的hypervisor进行通信，备份虚拟机的hypervisor可以知道应该向备份虚拟机传送哪些中断。

然而，即使很小心地使用间隔计时器，我们也不能保证主备虚拟机上的hypervisor能够在虚拟机的指令流的相同位置收到控制信息。这是因为，大多数现代处理器上的指令执行的时间是不可预料的。然而，主备虚拟机的指令流必须在相同的地方收到中断。当虚拟机的指令流到了一个特定的地方时，我们必须采用其它一些传送控制信息给hypervisor的机制。

当一条指令完成时，HP的PA-RISC处理器上的恢复寄存器(recovery register)减1；当恢复寄存器变成了负数时，就会引发一个中断。有了恢复寄存器，hypervisor可以让虚拟机执行固定数目的指令，然后收到控制信息，并且，在那个时间间隔内传递并阻塞收到的中断。使用恢复寄存器的hypervisor能够保证主备虚拟机的指令流在相同地方开始和完成。只有在边界地方，才会传递中断。

因此，对于恢复寄存器或者其它类似的机制，我们假设：

**指令流中断假设：**当到了指令流的一个特定的地方，这种机制可以调用hypervisor(也就是让hypervisor知道，指令执行到了一个特定的地方)。

除了HP的PA-RISC上的恢复寄存器，也可以采用DEC Alpha的性能计数器(performance counters)，或者事件计数器。对象代码编辑(Object-code editing)给出了另一种方案保证主备hypervisors在一个虚拟机指令流的相同地方被调用。在这种方案中，内核和所有的用户进程的对象代码被编辑，以便hypervisor周期性地被调用。或者，当用编译器生成程序时，能够简单改变编译器的代码生成器来周期性地调用hypervisor。

有了指令流中断假设，虚拟机的执行可以被分割为多个阶段(epochs)，主备虚拟机上的对应的epochs包含相同的指令序列。在一个时间段中，不会传递中断-中断被缓冲，只有在时间段边界才会传递。这种解决方案是为了使主备hypervisor通信，在一个时间段i结束时，备份hypervisor传递中断的拷贝，这些中断是主hypervisor在它的时间段i结束时传递的。

现在，我们对保证主备虚拟机执行相同指令序列并接收相同中断的协议进行总结。为了简化陈述，我们假设，连接主备处理器的通道是FIFO形式的。我们还假设执行备份虚拟机的处理器只有当收到主hypervisor的最后一条消息之后才会检测主处理器故障。主hypervisor保存计数器ep，备份hypervisor保存计数器eb，这些计数器保存了当前主备虚拟机各自的阶段编号。

协议包含一系列过程，我们在hypervisor中实现了这些过程。这些过程可能可以并发执行。我们用Tmep表示执行主虚拟机的处理器的虚拟的间隔计数器和时钟，用Tmeb表示备份虚拟机的相同寄存器。在每个时间阶段(epoch)，备份hypervisor接收Tmep，hypervisor就能够重新同步它的时钟，这样，主hypervisor会在每个epoch最后调度间隔计数器中断。

首先，我们看看这种情况：运行主虚拟机的处理器还没有故障。

P0：如果ep = E，并且主hypervisor执行一条环境指令：

* 主hypervisor将[E，Val]发送给备份hypervisor，其中Val是执行环境指令产生的值。

P1：如果ep = E，并且主hypervisor收到一个中断Int：

* 主hypervisor将[E，Int]发送给备份hypervisor；
* 主hypervisor缓冲Int，之后再传递

P2：如果ep = E，并且主hypervisor的epoch结束了：

* 主将[Tmep]发送给备份；
* 主等待之前发送给备份的所有消息的确认；
* 主缓冲任何基于Tmep的中断；
* 主传递epoch E的所有缓冲的中断；
* 主将[end，E]发送给备份；
* ed := ep + 1;
* 主开始epoch E+1

P3：如果备份hypervisor收到备份虚拟机发送的中断Int，它会忽略Int。

P4：如果备份hypervisor收到从主hypervisor发送的[E，Int]：

* 备份hypervisor向主发送一个确认；
* 备份缓冲Int，在epoch E结束时传递

P5：如果eb = E，并且备份epoch结束：

* 备份等待主的[Tmep]消息；
* Tmeb := Tmep；
* 备份等待主的[end，E+1]；
* 备份缓冲基于Tmeb的中断；
* 在epoch E结束时，备份传递所有缓冲的中断；
* eb := eb + 1；
* 备份开始epoch E+1

P6：如果ep = E，并且备份hypervisor处理环境指令：

* 返回值是主根据P0发送的值

现在，考虑执行主虚拟机的处理器故障了。假设故障发生在启动epoch E+1之后，但是在向备份hypervisor发送[end，E+1](in P2)之前。备份hypervisor没有义务在epoch E+1的那个地方(主故障了)继续执行，因此，备份能够继续执行指令(并且忽略从备份处理器发送的中断)直到 epoch E+1结束。然而，在备份虚拟机到达epoch E结束之后，它没有从主hypervisor收到期望的[end，E+1]。故障检测通知会代替这个消息。最后，在epoch E+2开始时，备份会被提升为主，因此，在每个epoch阶段，只有一个主。

P7：如果eb = E，并且备份的epoch结束时：

* 备份等候检测主故障；
* 备份缓冲基于Tmeb的中断；
* 备份传递epoch E结束时缓冲的所有中断；
* eb := eb + 1；
* 备份开始阶段epoch E+1；
* 备份被提升为主，开始epoch E+2

理解从P0到P7完成什么，没有完成什么，是很重要的。P0到P7保证了备份虚拟机跟主虚拟机执行相同的指令序列。P0到P7还保证，如果主虚拟机故障了，备份虚拟机执行的指令会扩展到主虚拟机执行的指令序列。

P0到P7不会保证从I/O设备的中断不丢失()。如果运行主虚拟机的处理器在成功延迟传递到主hypervisor的I/O中断之前故障了，那么，中断就会丢失。下一部分扩展协议来处理I/O中断丢失的情况和保证外界在响应故障后不会看到异常行为的更加普遍的情况。
