## Hypervisor-based Fault-tolerance

原文链接：[Hypervisor-based Fault-tolerance](http://css.csail.mit.edu/6.824/2014/papers/bressoud-hypervisor.pdf)

摘要：本文描述了实现容错计算机系统的协议。这些协议对虚拟机管理员的管理程序进行补充，使主虚拟机和它的备份虚拟机协同工作。就可以构造容错计算机系统。要求不改变硬件、操作系统或者引用程序。这个原型系统运行程序时，比裸机慢2倍。

## 1 绪论

实现容错的一个主流方案是当处理器工作异常时，复制处理器上的计算。副本之间需要协调，以便它们执行相同的指令序列，并产生相同的结果。本文描述了这种方案的一个新奇的实现。我们在硬件和操作系统之间加入了一个软件层。这样构造的容错计算机系统不需要改变硬件、操作系统和应用程序。

我们的方法的好处是：考虑了工程和推广市场的时间的开销。这是基于两个方面。首先，对于一个给定的指令集架构，厂商会开发一系列的实现，在这些系列中，成本/性能(原文是cost/performance，个人认为应该是性价比)提高了。其次，无论是用硬件还是软件实现副本协调，都是很微妙的(原文是subtle)。根据这些观察，我们注意到以下三个问题：

(1) 如果在硬件上实现副本协调，那么，在实现每个架构时都会产生设计开销。由于设计副本协调硬件很耗时，需要支持容错就必然落后于成本/性能曲线。

(2) 由于成熟的操作系统都是很复杂的，因此，向已经存在的操作系统中添加副本协调机制是很困难的。另外，对于每个平台支持的操作系统，都要做出改变。

(3) 如果副本协调问题留给应用程序开发人员，那么每个应用程序的开发人员都必须解决同样的问题。而且，所有的程序员都必须熟悉副本协调的细微差别。或者，所有的程序员都只能使用给定的一些接口或者抽象。

这些问题促使我们探索在计算机系统中实现副本协调时，可以将副本协调实现在硬件、操作系统还是应用程序部分。

hypervisor是实现了虚拟机的软件层次，这些虚拟机拥有和hypervisor运行的硬件相同的指令集架构。由于虚拟机的指令集架构跟裸机一样，运行在虚拟机上的软件不能区分hypervisor是否存在。最有名的hypervisor可能就是IBM为360/67开发的CP-67和之后为370大型机开发的VM/360了。

有多种原因使用hypervisor。hypervisor允许在一个处理器上同时存在多个操作系统或者是同一操作系统的多个版本。即使多个虚拟机同时运行同一个操作系统，hypervisor提供了隔离，它简化了保护和共享。然而，我们的研究没有关注hypervisor本身的价值和成本。我们关注的是增加hypervisor以支持副本协调和容错的价值和成本。

使用hypervisor实现副本协调是有诱惑力的-至少在理论上-因为它解决了上面提到的三个问题。对于给定的指令集架构的所有硬件实现，可以快速在hypervisor上实现副本协调，甚至包括那些当hypervisor写完时，并不存在的硬件的实现。这解决了问题(1)。对于问题(2)，我们注意到，在硬件上实现副本协调意味着一个实现可以满足运行在该指令集架构上的所有操作系统。最后，在hypervisor上实现副本协调可以解除应用程序开发人员实现副本协调时使用接口和抽象，这样就解决了问题(3)。

接下来的问题是，基于hypervisor的副本协调是否是可实现的。性能损失在哪里？本文解决了这些问题，描述了相关的协议和基于hypervisor的容错的原型系统的性能。这个原型系统运行程序比裸机要慢2倍。

本文的余下部分以下面的方式组织。第2部分，我们描述了一些协议。这些协议保证在不同的物理处理器上运行的两个虚拟机执行的指令序列是一样的。这些协议还要协调这些虚拟机发出的I/O。第3部分，我们会讨论原型系统。为了实现这个原型系统，我们为HP的PA-RISC架构实现了一个hypervisor，然后加入了我们的副本协调协议。第4部分，我们报告我们的原型系统的性能。除了讨论性能测试，我们还描述了可能改变原型的性能的变化的结果(we describe the consequences of variations that might improve performance of the prototype)。最后，第5部分，我们讨论了相关工作，第6部分我们进行总结然后给出未来研究方向的指导。

## 2 副本协调协议

使用主/备的方法实现容错，n个处理器实现的系统可以容n-1个错误。一个处理器作为主处理器，其它的都是备份处理器。为了获取服务，客户端向主处理器发送请求。主处理器对每个请求进行响应，并且通知备份处理器它的行为，以便当主处理器故障时，某个备份处理器可以代替它。

我们的容错虚拟机的实现在hypervisor中使用了主/备的方法。容t个错的虚拟机由一个主虚拟机和t个备份虚拟机构成。只要故障的处理器的个数等于或者少于t，容t个错的虚拟机就可以继续运行。

协议保证：

(1) 如果主处理器没有故障，备份虚拟机不会同外界进行通信；

(2) 如果主处理器故障了，某个备份虚拟机就会同外界通信，这样的话，外界并不知道主处理器的故障。对于虚拟机而言，“外界”包括虚拟机可以访问的虚拟机的I/O设备。

我们的协议使用了一个备份，并且实现了容1个错的虚拟机；容t个错的虚拟机是一样的。协议保证备份虚拟机执行的指令序列跟主虚拟机相同，备份处理器执行的每条指令的结果跟主处理器相同。协议还保证，当一个I/O操作正在执行时，如果主处理器故障了，备份处理器代替它时，外界不会看到异常的I/O请求序列。

需要做一个假设，以便备份虚拟机能够代替主虚拟机，考虑I/O设备的可访问性：

**I/O设备的可访问假设：**执行主虚拟机的处理器可以访问的I/O设备也能够被执行备份虚拟机的处理器访问。

第二个假设是必要的，因为hypervisor要模拟特定的指令。这些指令在hypervisor的执行时间可能跟直接在硬件上执行不同。使用hypervisor还可能影响程序可以访问的实际内存。因此，我们假设，虚拟机上运行的这个软件不会影响操作系统和其它程序的正确性：

**虚拟机假设：**加上hypervisor，系统和用户软件可以正确执行。

在下面讨论的其它假设考虑了执行多种指令的影响。(We ignore here the problem of replacing the backup after it fails or becames the primary)，因为这个问题对于副本协调是正交的，很容易解决。
